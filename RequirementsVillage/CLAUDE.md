# CLAUDE.md - RequirementsVillage

## 🎯 Project Context

This is the unified solution for Requirements Village, combining a .NET 9 Minimal API backend with a SvelteKit static SPA frontend. The API serves both the static client files and backend endpoints from a single application.

## 🧰 Tech Stack

### Backend
- **Framework:** .NET 9 Minimal API
- **Language:** C# (functional style with LanguageExt)
- **Functional Library:** LanguageExt 4.4.9
- **Database:** SQLite (planned)
- **ORM:** Entity Framework Core (planned)
- **Authentication:** ASP.NET Core Identity (planned)
- **Testing:** xUnit + FluentAssertions + Moq

### Frontend
- **Framework:** SvelteKit (static SPA)
- **Language:** TypeScript
- **Styling:** Tailwind CSS + DaisyUI
- **Build:** Vite
- **Testing:** Vitest + Playwright

## 📁 Key Files

```
RequirementsVillage/
├── RequirementsVillage.Api/      # Backend API project
│   ├── Program.cs                # Main entry point with endpoints + static file serving
│   ├── Endpoints/                # Feature-based endpoint groups
│   ├── Extensions/               # Service registration extensions
│   └── wwwroot/                  # Static client files (generated by build)
├── RequirementsVillage.Client/   # Frontend SvelteKit project
│   ├── src/                      # Source code
│   ├── svelte.config.js          # SvelteKit configuration
│   └── package.json              # Node dependencies
├── RequirementsVillage.Domain/   # Business logic layer
│   ├── Interfaces/               # Service interfaces
│   └── Services/                 # Service implementations
├── RequirementsVillage.Models/   # Shared data models
│   └── Project.cs                # Core domain entities
├── RequirementsVillage.Persistence/ # Data access layer
│   ├── Interfaces/               # Repository interfaces
│   └── Repositories/             # Repository implementations
├── RequirementsVillage.Api.Tests/ # API integration tests
│   ├── Infrastructure/           # Test setup and factories
│   └── Endpoints/                # Endpoint test classes
└── RequirementsVillage.sln       # Visual Studio/Rider solution
```

## 🛠️ Development Commands

### Full Stack Development
```bash
# Terminal 1: Run the API (serves both API and static files)
cd RequirementsVillage
dotnet run --project RequirementsVillage.Api

# Terminal 2: Run client dev server (for hot reload during development)
cd RequirementsVillage/RequirementsVillage.Client
npm run dev
```

### Build for Production
```bash
# Build client static files
cd RequirementsVillage/RequirementsVillage.Client
npm run build

# Build and run the API (serves everything)
cd RequirementsVillage
dotnet build
dotnet run --project RequirementsVillage.Api
```

### Individual Commands
```bash
# Backend
dotnet restore              # Restore .NET packages
dotnet build                # Build .NET project
dotnet test                 # Run .NET tests

# Frontend
npm install                 # Install Node packages
npm run dev                 # Development server with hot reload
npm run build              # Build static files to wwwroot
npm test                   # Run frontend tests
npm run lint               # Lint TypeScript/Svelte files
```

## 🌐 Current Endpoints

### API Endpoints
- `GET /api/health` - Health check with timestamp
- `GET /api/projects` - Get all projects (returns 2 hardcoded examples)

### Static Routes (Client)
- `GET /` - Main application (SPA)
- `GET /dashboard` - Dashboard page
- All other routes handled by SPA fallback

## 🏗️ Architecture Overview

This API follows a **layered architecture** with clean separation of concerns and dependency injection throughout. The architecture emphasizes business rule enforcement, type safety through Result types, and functional programming patterns.

### 🎯 Core Principles

- **Business Logic Protection:** Domain services enforce business rules and prevent misuse of the persistence layer
- **Railway Oriented Programming (ROP):** Use discriminated unions and Result types for predictable error handling
- **Immutable Data:** Models are immutable records where possible
- **Dependency Injection:** All services injected via interfaces for testability and flexibility
- **Single Responsibility:** Each layer has a focused purpose

### 📁 Project Structure

```
Api/
├── Program.cs              # Main entry point + DI setup
├── Endpoints/              # Endpoint groups (ProjectEndpoints.cs, etc.)
├── Extensions/             # Service registration extensions
├── Middleware/             # Custom middleware (if needed)
└── Api.csproj

Domain/
├── Interfaces/
│   └── IProjectService.cs  # Domain service interfaces
├── Services/
│   └── ProjectService.cs   # Business logic services
└── Domain.csproj

Models/
├── Project.cs              # Immutable records (shared by API and EF)
├── Category.cs
├── User.cs
└── Models.csproj

Persistence/
├── Interfaces/
│   └── IProjectRepository.cs  # Repository interfaces
├── Repositories/
│   └── ProjectRepository.cs   # CRUD implementations
├── Data/                      # DbContext and configurations
└── Persistence.csproj

Api.Tests/
├── Infrastructure/
│   └── TestWebApplicationFactory.cs  # Test setup and factories
├── Endpoints/
│   ├── HealthCheckTests.cs          # Health check endpoint tests
│   └── ProjectEndpointsTests.cs     # Project endpoint tests
└── Api.Tests.csproj

RequirementsVillage.sln
```

### 🔄 Data Flow

```
API Endpoints → Domain Services → Repository Interfaces → Repository Implementations → Database
     ↑              ↑                     ↑                        ↑
   Minimal API   Business Rules    Interface Contracts        CRUD Operations
```

### 🎭 Layer Responsibilities

#### **Api Layer**
- **Purpose:** HTTP endpoints and request/response handling
- **Contains:** Minimal API endpoints organized by feature
- **Dependencies:** Domain service interfaces only
- **Pattern:** Endpoint handlers pattern match on Result types from Domain services

#### **Domain Layer** 
- **Purpose:** Business logic and rule enforcement
- **Contains:** Services that validate business rules and coordinate data operations
- **Dependencies:** Models + Persistence interfaces
- **Error Handling:** Returns Result<TSuccess, TError> types using Railway Oriented Programming
- **Rule Enforcement:** Prevents misuse of persistence layer through validation

#### **Models Layer**
- **Purpose:** Shared data structures
- **Contains:** Immutable records used by both API serialization and Entity Framework
- **Dependencies:** None (pure data)
- **Note:** Single model set (no DTOs unless specifically needed)

#### **Persistence Layer**
- **Purpose:** Data access and CRUD operations
- **Contains:** Repository implementations, DbContext, and EF configurations
- **Dependencies:** Models only
- **Pattern:** Simple CRUD operations with no business logic

### 🏷️ Naming Conventions

#### **Services & Interfaces**
- **Domain Services:** `ProjectService`, `CategoryService`, `UserService`
- **Domain Interfaces:** `IProjectService`, `ICategoryService`, `IUserService`  
- **Repositories:** `ProjectRepository`, `CategoryRepository`, `UserRepository`
- **Repository Interfaces:** `IProjectRepository`, `ICategoryRepository`, `IUserRepository`

#### **Models**
- **Models:** `Project`, `Category`, `User` (used for both API and database)
- **Result Types:** `Result<Project, Error>`, `Result<List<Project>, Error>`

#### **Endpoints**
- **Endpoint Classes:** `ProjectEndpoints`, `CategoryEndpoints`, `UserEndpoints`
- **Methods:** `MapProjectEndpoints()`, `GetAllProjects()`, `CreateProject()`

### 🚂 Railway Oriented Programming with LanguageExt

#### **Why Railway Oriented Programming**
1. **Compile-time Safety:** Forgetting to handle errors causes compilation errors
2. **Explicit Contracts:** Method signatures show what can fail
3. **Type System Integration:** Failures are part of the type system
4. **Composable:** Chain operations without nested error checking
5. **Predictable Flow:** Success and failure paths are explicit

#### **Current Implementation**
Using LanguageExt's `Either<L, R>` type where:
- `L` (Left) represents the error case
- `R` (Right) represents the success case

#### **Usage Pattern**
```csharp
// Domain Service
public async Task<Either<Error, Seq<Project>>> GetAllProjectsAsync() {
    try {
        var projects = await _repository.GetAllAsync();
        return Right<Error, Seq<Project>>(projects);
    }
    catch (Exception ex) {
        return Left<Error, Seq<Project>>(
            Error.New($"Failed to retrieve projects: {ex.Message}")
        );
    }
}

// API Endpoint with pattern matching
private static async Task<IResult> GetAllProjects(
    IProjectService service
) {
    var result = await service.GetAllProjectsAsync();
    
    return result.Match(
        Left:  error => Results.Problem(error.Message),
        Right: projects => Results.Ok(projects)
    );
}
```

### 🔌 Dependency Injection Setup

#### **Service Lifetimes**
- **Domain Services:** Scoped (per request)
- **Repositories:** Scoped (per request)  
- **DbContext:** Scoped (per request)

#### **Registration Pattern**
```csharp
// In Program.cs or Extensions
builder.Services.AddScoped<IProjectService, ProjectService>();
builder.Services.AddScoped<IProjectRepository, ProjectRepository>();
```

## 📝 Development Notes

### **Current State**
- Unified Rider solution with multiple projects (Api, Domain, Models, Persistence, Api.Tests)
- Layered architecture implemented with clean separation of concerns
- LanguageExt integrated for functional programming patterns
- Basic API endpoint working with hardcoded data
- API integration tests using WebApplicationFactory pattern
- SvelteKit configured as static SPA (no SSR)
- API serves both static files and backend endpoints
- Client builds to wwwroot directory
- Tests verify health check and project endpoints functionality

### **Development Workflow**
1. **For frontend development:** Run both `dotnet run` and `npm run dev` simultaneously
   - Access the app at `http://localhost:5173` for hot reload
   - API calls will proxy to the .NET backend automatically
2. **For API development:** Just run `dotnet run`  
   - Access at `http://localhost:5000` to test with built static files
3. **Before deployment:** Run `npm run build` to update wwwroot

### **Implementation Strategy**
- Start with single project, refactor to multi-project structure  
- Implement Result types early for consistent error handling
- Add business services incrementally with proper validation
- Database and authentication features planned for later commits

### **Key Dependencies (Planned)**
- Entity Framework Core for data access
- ASP.NET Core Identity for authentication
- Result library (ErrorOr, OneOf, or custom implementation)
- SQLite for local development

## 🎨 Code Formatting Guidelines

### General Formatting
- **Indentation:** 4 spaces for all C# files (always 4 spaces, even for wrapping)
- **Braces:** Opening braces on the same line (K&R style)
- **Quotes:** Single quotes for character literals, double quotes for strings
- **Semicolons:** Always required for C# statements
- **Line Length:** 80 characters maximum (hard limit)
- **Exception:** Long URLs and string literals are exempt from 80-column limit and should not be wrapped

### Using Statements & Imports
- Group using statements by type with blank lines between groups:
  ```csharp
  // System namespaces
  using System;
  using System.Collections.Generic;
  
  // Third-party libraries
  using Microsoft.AspNetCore.Mvc;
  
  // Project namespaces
  using RequirementsVillage.Api.Models;
  ```

### Method Parameters & Arguments
- **Parameter Lists:** If more than 2 parameters, place each on its own line with aligned formatting:
  ```csharp
  // 2 or fewer parameters - single line
  public void ProcessRequest(string id, bool isActive)
  
  // 3+ parameters - multi-line with aligned formatting
  public async Task<ActionResult> CreateProject(
      string        name,
      string        description,
      ProjectStatus status,
      DateTime      createdAt
  ) {
  ```

### Object Initialization & Method Calls
- **Property Alignment:** For object initializers and method calls with multiple arguments:
  ```csharp
  var project = new Project {
      Id          = Guid.NewGuid(),
      Name        = "Sample Project",
      Description = "A sample project description",
      Status      = ProjectStatus.Active,
      CreatedAt   = DateTime.UtcNow
  };
  ```

### Attribute Alignment
- **Multiple Attributes:** Place each attribute on its own line:
  ```csharp
  [HttpPost]
  [Route("api/projects")]
  [Authorize(Roles = "Admin")]
  public async Task<ActionResult<Project>> CreateProject([FromBody] CreateProjectRequest request)
  ```

### Status
- **✅ Applied:** All formatting guidelines have been applied to the entire API codebase
- **📁 Scope:** All `.cs` files in the API project